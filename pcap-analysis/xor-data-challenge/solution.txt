This practice session covers a challenge using pcap analysis called "pa050" and there are three references I would like you to take a look at prior to August 29th (our next session).

- https://www.fireeye.com/blog/threat-research/2015/02/anatomy_of_a_brutef.html
- http://reverseengineering.stackexchange.com/questions/2062/what-is-the-most-efficient-way-to-detect-and-to-break-xor-encryption
- http://digital-forensics.sans.org/blog/2013/05/14/tools-for-examining-xor-obfuscation-for-malware-analysis

At a minimum take a look at the 2nd reference. It describes how an XOR key works and is key for getting the flag for the challenge. The 1st reference provides background for what is occurring in the pcap and the 3rd reference provides several tools recommended by SANS to use with XOR decoding.

In this walk-thru I will focus on parsing through the small pcap, some things to look at in a pcap when you are conducting analysis, and then walk through another team's method of solving the pa050 challenge. I've created a new repo on our github site that will host materials we cover in this monthly practice sessions located @ https://github.com/mcpa. 

Last, just like last time after I'm done with the walk-thru time dependent we can try some live events online. The goal is for this session to last between 1-2 hours depending on interest. I'm still working on a good way to work through how we all participate online together and yet record the session at the same time. For now - it will work the same way as last time - an onair google hangout @ https://plus.google.com/events/c6b1tbsmupkodiuimhlscdkt98s?authkey=CKzx46nD_obNCA

----------------------------- SOLUTION WRITE-UP BELOW -----------------------------

1. Google ANY of the domains from the pcap, there are writeups galore on their maliciousness
Here's an example: https://www.fireeye.com/blog/threat-research/2015/02/anatomy_of_a_brutef.html

1a. Big takeways - it's an actual bot, and it uses XOR encryption.
1b. Looking at the pcap holistically, it looks for sketchy domains, tries to pull down a config (fails), tries 2 C&C servers before actually establishing a connection with the 3rd. It tries some very shady networking, gets sent a command, then starts sending garbage on port 80.  Read the writeups for more on why it's doing this (hint: the answer is in the nomenclature).

2. Here's the crappy part from all the writeups which mostly call out the XOR key.  First, the key is larger than usual.  Second, the key listed on the blogs looks like hex (which would make it an 8 byte key - BB2FA36AAA9541F0), but is actually the ASCII representation of those bytes (so it's 16 bytes - 42423246413336414141393534314630).  You'll see this key repeating the packet capture.
3. The key packets are actually sent in 3 separate streams (tcp.stream eq 2/3/4), all with data lengths of 272 bytes. Packets 24, 33, and 41 are the ones you need.
4. Click on packet 41 in wireshark, select just the data section in the lower display, copy that off somewhere.  I did clicked on just the data section, right clicked, then selected Copy -> Bytes -> Hex Stream

ab4132464b333641bebec6ca071f761e726f01746c54532f24335056343146304242324641333641414139353431463042423246413336414141393534314630424232464133364141413935345870087442324641333641414139353431463042423246413336414141393534314630424232464133364141413935343146304242324641333641414139353431771a717106704133364141413935343146304242324641333641414139353431463042423246413336414141393534314630424232464133364141413935343146472c38583e2e5150322229405250563e553a2d5c293340422430295c415046343011167312087036414141393534314630706c0268713336414141393534314630

5. So now we have the key, and the data.  If you have a windows tool that does multiple byte XOR decoding, bless you, this will be easy.  I defined an xor function in python for an arbitrary key length, and to play with it in bytearray format.

def xor(d, k):
    l = len(k)
    return bytearray((
        (d[i] ^ k[i % l]) for i in range(0,len(d))
    ))

d = bytearray('ab4132464b333641bebec6ca071f761e726f01746c54532f24335056343146304242324641333641414139353431463042423246413336414141393534314630424232464133364141413935345870087442324641333641414139353431463042423246413336414141393534314630424232464133364141413935343146304242324641333641414139353431771a717106704133364141413935343146304242324641333641414139353431463042423246413336414141393534314630424232464133364141413935343146472c38583e2e5150322229405250563e553a2d5c293340422430295c415046343011167312087036414141393534314630706c0268713336414141393534314630'.decode('hex'))
k = bytearray('42423246413336414141393534314630'.decode('hex'))

>>> print xor(d,k)

[garbage]3.0.0-32-generici6861*3346wnzjxobfschygdgxexonorsteqhetdwrSTATIC2.0.0

6. For those that haven't run a 'uname -r' lately, you can see the kernel version above (3.0.0-32-generic), and read more of the writeup to see why it sends that.
